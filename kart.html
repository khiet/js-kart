<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<script>
  let canvas;
  let canvasContext;
  let ballX = 0;
  let ballY = 0;

  let ballSpeedX = 5;
  let ballSpeedY = -5;
  let ballRadius = 10;

  let TRACK_ROWS = 30;
  const TRACK_COLUMNS = 40;
  // 800 is canvas width
  const TRACK_W = 800 / TRACK_COLUMNS;
  const TRACK_H = 600 / TRACK_ROWS;
  let trackGrid = new Array(TRACK_ROWS * TRACK_COLUMNS);
  let trackLeft = 0;

  let mouseX;
  let mouseY;

  const directions = {
    TOP_LEFT: 0,
    TOP_RIGHT: 1,
    BOTTOM_RIGHT: 2,
    BOTTOM_LEFT: 3,
  }

  document.addEventListener('DOMContentLoaded', function () {
    canvas = document.getElementById("gameCanvas");
    canvasContext = canvas.getContext('2d');

    let fps = 30;
    setInterval(callBoth, 1000 / fps);

    resetTracks();
    resetBall();
  });

  function resetTracks() {
    trackLeft = 0;
    for (let i = 0; i < TRACK_ROWS * TRACK_COLUMNS; i++) {
      trackLeft++;
      trackGrid[i] = true;
    }
  }

  function drawTracks() {
    const trackMargin = 2;

    for (let i = 0; i < TRACK_ROWS; i++) {
      for (let j = 0; j < TRACK_COLUMNS; j++) {
        let trackIndex = trackIndexAtRowColumn(i, j);

        if (trackGrid[trackIndex]) {
          colorRect(TRACK_W * j, TRACK_H * i, TRACK_W - trackMargin, TRACK_H - trackMargin, 'blue');
        }
      }
    }
  }

  function debugControlBallWithMouse(e) {
    let mousePos = calculateMousePos(e);
    ballX = mousePos.x;
    ballY = mousePos.y;

    ballSpeedX = 5;
    ballSpeedY = -5;
  }

  function resetBall() {
    // set ball at center
    ballX = canvas.width / 2;
    ballY = canvas.height * 0.75

    ballSpeedX = 5;
    ballSpeedY = -5;
  }

  function calculateMousePos(event) {
    let rect = canvas.getBoundingClientRect();
    let root = document.documentElement;
    mouseX = event.clientX - rect.left - root.scrollLeft;
    mouseY = event.clientY - rect.top - root.scrollTop;
    let result = {
      x: mouseX,
      y: mouseY
    };

    return result;
  }
  function callBoth() {
    moveAll();
    drawAll();
  }

  function ballMove() {
    ballX += ballSpeedX;
    ballY += ballSpeedY;

    if (ballX < 0) {
      ballX += -ballSpeedX;
      ballSpeedX = -ballSpeedX;
    }

    if (ballX > canvas.width) {
      ballX += -ballSpeedX;
      ballSpeedX = -ballSpeedX;
    }

    if (ballY < 0) {
      ballY += -ballSpeedY;
      ballSpeedY = -ballSpeedY;
    }

    if (ballY > canvas.height) {
      ballY += -ballSpeedY;
      ballSpeedY = -ballSpeedY;
    }
  }

  function ballTrackHandling() {
    let trackIndex = trackIndexAt(ballX, ballY);
    if (trackIndex >= 0 && trackIndex < trackGrid.length && ballX > 0 && ballX < canvas.width) {
      if (trackGrid[trackIndex]) {

        let previousTrackRowColumn = trackRowColumnAt(ballX - ballSpeedX, ballY - ballSpeedY);
        let currentTrackRowColumn = trackRowColumnAt(ballX, ballY);
        let diffRow = previousTrackRowColumn.row != currentTrackRowColumn.row;
        let diffColumn = previousTrackRowColumn.column != currentTrackRowColumn.column;
        let ballDirection = directionAtSpeed(ballSpeedX, ballSpeedY);

        trackGrid[trackIndex] = false;
        trackLeft--;
        //Users/khietle/Desktop/Screenshot\ 2020-04-20\ at\ 16.20.46.png / ball hits left or right of the track (ball comes from different column)
        if (diffColumn) {
          ballSpeedX = -ballSpeedX;
        }
        // ball hits bottom or top of the track (ball comes from different row)
        if (diffRow) {
          ballSpeedY = -ballSpeedY;
        }
        // ball hits corner of the track
        if (diffColumn && diffRow) {
          const topTrack = trackGrid[trackIndex - TRACK_COLUMNS];
          const bottomTrack = trackGrid[trackIndex + TRACK_COLUMNS];
          const leftTrack = trackGrid[trackIndex - 1];
          const rightTrack = trackGrid[trackIndex + 1];

          if (ballDirection === directions.TOP_LEFT) {
            if (topTrack && leftTrack) {
              return;
            }

            if (topTrack) {
              ballSpeedY = -ballSpeedY;
            }
            if (leftTrack) {
              ballSpeedX = -ballSpeedX;
            }
          }
          if (ballDirection === directions.TOP_RIGHT) {
            if (topTrack && rightTrack) {
              return;
            }

            if (topTrack) {
              ballSpeedY = -ballSpeedY;
            }
            if (rightTrack) {
              ballSpeedX = -ballSpeedX;
            }
          }
          if (ballDirection === directions.BOTTOM_RIGHT) {
            if (bottomTrack && rightTrack) {
              return;
            }

            if (bottomTrack) {
              ballSpeedY = -ballSpeedY;
            }
            if (rightTrack) {
              ballSpeedX = -ballSpeedX;
            }
          }
          if (ballDirection === directions.BOTTOM_LEFT) {
            const bottomTrack = trackGrid[trackIndex + TRACK_COLUMNS];
            const leftTrack = trackGrid[trackIndex - 1];

            if (bottomTrack && leftTrack) {
              return;
            }

            if (bottomTrack) {
              ballSpeedY = -ballSpeedY;
            }
            if (leftTrack) {
              ballSpeedX = -ballSpeedX;
            }
          }
        }
      }
    }
  }

  function directionAtSpeed(speedX, speedY) {
    if (speedX > 0) {
      if (speedY > 0) {
        return directions.TOP_LEFT;
      } else {
        return directions.BOTTOM_LEFT;
      }
    } else {
      if (speedY < 0) {
        return directions.BOTTOM_RIGHT;
      } else {
        return directions.TOP_RIGHT;
      }
    }
  }

  function moveAll() {
    ballMove();
    ballTrackHandling();
  }

  function colorRect(x, y, width, height, color) {
    canvasContext.fillStyle = color;
    canvasContext.fillRect(x, y, width, height);
  }

  function colorCircle(x, y, radius, color) {
    canvasContext.fillStyle = color;
    canvasContext.beginPath();
    canvasContext.arc(x, y, radius, 0, Math.PI * 2, true);
    canvasContext.fill();
  }

  function colorText(text, x, y, color, size = 16, textAlign = 'left') {
    canvasContext.textAlign = textAlign;
    canvasContext.font = `normal ${size}px Arial`;

    canvasContext.fillStyle = color;
    canvasContext.fillText(text, x, y);
  }

  function drawAll() {
    console.log('drawAll');
    console.log(ballX);
    console.log(ballY);
    colorRect(0, 0, canvas.width, canvas.height, 'black');
    drawTracks();

    // showDebugInfo();

    // at start (when ballX and ballY are 0), hide ball
    if (ballX && ballY) {
      colorCircle(ballX, ballY, ballRadius, 'white');
    }
  }

  function trackIndexAt(x, y) {
    let trackRowColumn = trackRowColumnAt(x, y);
    return trackIndexAtRowColumn(trackRowColumn.row, trackRowColumn.column);
  }

  function trackIndexAtRowColumn(row, column) {
    return (row * TRACK_COLUMNS) + column;
  }

  function trackRowColumnAt(x, y) {
    return {
      row: Math.floor(y / TRACK_H),
      column: Math.floor(x / TRACK_W)
    }
  }

  function showDebugInfo() {
    const yPosition = canvas.height / 2;
    // mouse position
    colorText(`(${Math.floor(mouseX)},${Math.floor(mouseY)})`, 5, yPosition, 'yellow');
    // row and column at mouse position
    let trackRowColumnAtMousePos = trackRowColumnAt(mouseX, mouseY);
    colorText(`(${trackRowColumnAtMousePos.row},${trackRowColumnAtMousePos.column})`, 5, yPosition + 20, 'yellow');
    // array index at row and column
    colorText(trackIndexAt(mouseX, mouseY), 5, yPosition + 40, 'yellow');
  }
</script>

<style>
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
  }
</style>

<body>
  <canvas id='gameCanvas' width='800' height='600'></canvas>
</body>

</html>
